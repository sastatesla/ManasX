import { EventEmitter } from 'events';
import http from 'http';
import fs from 'fs';
import path from 'path';
import { logger } from '../utils/logger.js';
import RuleEngine from '../governance/RuleEngine.js';
import AIDetector from '../ai-audit/AIDetector.js';

export default class MCPServer extends EventEmitter {
  constructor(options = {}) {
    super();
    
    this.monitor = null; // Will be loaded dynamically
    this.options = {
      port: options.port || 8765,
      host: options.host || 'localhost',
      maxRequestSize: options.maxRequestSize || 1024 * 1024, // 1MB
      corsEnabled: options.corsEnabled !== false,
      apiKey: options.apiKey, // Optional API key for security
      contextLogFile: options.contextLog || '.manasx/context.log',
      patternsFile: options.patterns || 'patterns.json',
      rulesFile: options.rules || 'manasx-rules.json',
      ...options
    };

    this.server = null;
    this.isRunning = false;
    this.requestCount = 0;
    this.startTime = null;

    this.tools = {
      'get-organizational-context': {
        name: 'get-organizational-context',
        description: 'Get organizational coding patterns, rules, and current monitoring status',
        inputSchema: {
          type: 'object',
          properties: {},
          required: []
        }
      },
      'check-code-compliance': {
        name: 'check-code-compliance',
        description: 'Check if code complies with organizational standards',
        inputSchema: {
          type: 'object',
          properties: {
            code: { type: 'string', description: 'Code to check' },
            filename: { type: 'string', description: 'Filename for context' }
          },
          required: ['code']
        }
      },
      'detect-ai-code': {
        name: 'detect-ai-code',
        description: 'Detect if code was likely generated by AI',
        inputSchema: {
          type: 'object',
          properties: {
            code: { type: 'string', description: 'Code to analyze' },
            filename: { type: 'string', description: 'Filename for context' }
          },
          required: ['code']
        }
      },
      'get-recent-violations': {
        name: 'get-recent-violations',
        description: 'Get recent code violations detected by monitoring',
        inputSchema: {
          type: 'object',
          properties: {
            limit: { type: 'number', description: 'Maximum number of violations to return', default: 10 },
            severity: { type: 'string', description: 'Filter by severity (critical, high, medium, low)', enum: ['critical', 'high', 'medium', 'low'] }
          },
          required: []
        }
      },
      'get-file-analysis': {
        name: 'get-file-analysis',
        description: 'Get detailed analysis for a specific file',
        inputSchema: {
          type: 'object',
          properties: {
            filepath: { type: 'string', description: 'Path to the file to analyze' }
          },
          required: ['filepath']
        }
      },
      'suggest-improvements': {
        name: 'suggest-improvements',
        description: 'Get improvement suggestions based on organizational patterns',
        inputSchema: {
          type: 'object',
          properties: {
            code: { type: 'string', description: 'Code to improve' },
            filename: { type: 'string', description: 'Filename for context' },
            focus: { type: 'string', description: 'Focus area (naming, imports, performance, security)', enum: ['naming', 'imports', 'performance', 'security', 'all'] }
          },
          required: ['code']
        }
      }
    };
  }

  async start(port) {
    if (this.isRunning) {
      logger.warn('MCP Server is already running');
      return;
    }

    try {
      await this.loadContext();
      
      const serverPort = port || this.options.port;
      this.server = http.createServer(this.handleRequest.bind(this));
      
      await new Promise((resolve, reject) => {
        this.server.listen(serverPort, this.options.host, (error) => {
          if (error) reject(error);
          else resolve();
        });
      });

      this.isRunning = true;
      this.startTime = new Date();
      
      logger.success(`MCP Server started on ${this.options.host}:${serverPort}`);
      logger.info(`Available tools: ${Object.keys(this.tools).join(', ')}`);
      
      this.emit('started', { 
        host: this.options.host, 
        port: serverPort,
        tools: Object.keys(this.tools)
      });
      
    } catch (error) {
      logger.error(`Failed to start MCP Server: ${error.message}`);
      throw error;
    }
  }

  async loadContext() {
    try {
      if (fs.existsSync(this.options.patternsFile)) {
        const content = fs.readFileSync(this.options.patternsFile, 'utf-8');
        this.learnedPatterns = JSON.parse(content);
        logger.info('Loaded organizational patterns');
      }

      if (fs.existsSync(this.options.rulesFile)) {
        const content = fs.readFileSync(this.options.rulesFile, 'utf-8');
        this.organizationalRules = JSON.parse(content);
        
        this.ruleEngine = new RuleEngine();
        await this.ruleEngine.loadRules(this.options.rulesFile);
        logger.info('Loaded organizational rules');
      }

      this.aiDetector = new AIDetector();

      if (fs.existsSync(this.options.contextLogFile)) {
        logger.info('Context log available for AI queries');
      }

    } catch (error) {
      logger.warn(`Could not load some context: ${error.message}`);
    }
  }

  async stop() {
    if (!this.isRunning || !this.server) {
      return;
    }

    await new Promise((resolve) => {
      this.server.close(() => resolve());
    });

    this.isRunning = false;
    const uptime = new Date() - this.startTime;
    
    logger.info(`MCP Server stopped. Uptime: ${Math.round(uptime / 1000)}s, Requests handled: ${this.requestCount}`);
    
    this.emit('stopped', { 
      uptime: Math.round(uptime / 1000),
      requestCount: this.requestCount
    });
  }

  async handleRequest(req, res) {
    if (this.options.corsEnabled) {
      res.setHeader('Access-Control-Allow-Origin', '*');
      res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
      
      if (req.method === 'OPTIONS') {
        res.writeHead(200);
        res.end();
        return;
      }
    }

    res.setHeader('Content-Type', 'application/json');
    res.setHeader('X-Content-Type-Options', 'nosniff');
    
    this.requestCount++;

    try {
      if (this.options.apiKey) {
        const authHeader = req.headers.authorization;
        if (!authHeader || authHeader !== `Bearer ${this.options.apiKey}`) {
          this.sendError(res, 401, 'Unauthorized');
          return;
        }
      }

      if (req.method === 'GET') {
        await this.handleGetRequest(req, res);
      } else if (req.method === 'POST') {
        await this.handlePostRequest(req, res);
      } else {
        this.sendError(res, 405, 'Method Not Allowed');
      }
      
    } catch (error) {
      logger.error(`MCP Server request error: ${error.message}`);
      this.sendError(res, 500, 'Internal Server Error');
    }
  }

  async handleGetRequest(req, res) {
    const url = new URL(req.url, `http://${req.headers.host}`);
    const path = url.pathname;

    switch (path) {
      case '/':
      case '/status':
        this.sendResponse(res, {
          status: 'running',
          uptime: this.startTime ? new Date() - this.startTime : 0,
          requestCount: this.requestCount,
          monitorStatus: this.monitor?.isRunning || false
        });
        break;

      case '/tools':
        this.sendResponse(res, {
          tools: Object.values(this.tools)
        });
        break;

      case '/health':
        this.sendResponse(res, {
          healthy: true,
          monitor: this.monitor?.isRunning || false,
          timestamp: new Date().toISOString()
        });
        break;

      default:
        this.sendError(res, 404, 'Not Found');
    }
  }

  async handlePostRequest(req, res) {
    const body = await this.readRequestBody(req);
    
    let requestData;
    try {
      requestData = JSON.parse(body);
    } catch (error) {
      this.sendError(res, 400, 'Invalid JSON');
      return;
    }

    const { method, params } = requestData;

    if (method && method.startsWith('tools/')) {
      const toolName = method.replace('tools/', '');
      await this.executeTool(toolName, params || {}, res);
    } else {
      this.sendError(res, 400, 'Invalid request format');
    }
  }

  async executeTool(toolName, params, res) {
    if (!this.tools[toolName]) {
      this.sendError(res, 404, `Tool '${toolName}' not found`);
      return;
    }

    try {
      let result;

      switch (toolName) {
        case 'get-organizational-context':
          result = await this.getOrganizationalContext();
          break;

        case 'check-code-compliance':
          result = await this.checkCodeCompliance(params.code, params.filename);
          break;

        case 'detect-ai-code':
          result = await this.detectAICode(params.code, params.filename);
          break;

        case 'get-recent-violations':
          result = await this.getRecentViolations(params.limit, params.severity);
          break;

        case 'get-file-analysis':
          result = await this.getFileAnalysis(params.filepath);
          break;

        case 'suggest-improvements':
          result = await this.suggestImprovements(params.code, params.filename, params.focus);
          break;

        default:
          this.sendError(res, 501, 'Tool not implemented');
          return;
      }

      this.sendResponse(res, {
        content: [
          {
            type: 'text',
            text: JSON.stringify(result, null, 2)
          }
        ]
      });

    } catch (error) {
      logger.error(`Tool execution error (${toolName}): ${error.message}`);
      this.sendError(res, 500, `Tool execution failed: ${error.message}`);
    }
  }


  async getOrganizationalContext() {
    const recentActivity = await this.getRecentActivityFromLogs();
    
    return {
      timestamp: new Date().toISOString(),
      monitoring: {
        isActive: false, // Standalone MCP server
        contextAvailable: fs.existsSync(this.options.contextLogFile)
      },
      patterns: {
        available: !!this.learnedPatterns,
        summary: this.learnedPatterns ? {
          confidence: this.learnedPatterns.confidence,
          namingConventions: this.learnedPatterns.patterns?.naming || 'Not analyzed',
          importStyle: this.learnedPatterns.patterns?.imports || 'Not analyzed'
        } : null
      },
      rules: {
        configured: !!this.organizationalRules,
        categories: this.organizationalRules ? 
          Object.keys(this.organizationalRules.rules || {}).map(rule => rule.split('/')[0]) : []
      },
      recentActivity: recentActivity.slice(0, 5)
    };
  }

  async getRecentActivityFromLogs() {
    try {
      if (!fs.existsSync(this.options.contextLogFile)) {
        return [];
      }

      const content = fs.readFileSync(this.options.contextLogFile, 'utf-8');
      const lines = content.trim().split('\n').slice(-20); // Last 20 lines
      
      return lines
        .map(line => {
          try {
            return JSON.parse(line);
          } catch {
            return null;
          }
        })
        .filter(entry => entry && entry.event === 'file_analyzed')
        .slice(-10); // Keep last 10 analysis events
    } catch (error) {
      return [];
    }
  }

  async checkCodeCompliance(code, filename = 'temp.js') {
    if (!this.ruleEngine) {
      return { error: 'Rule engine not available - ensure organizational rules are configured' };
    }

    try {
      const violations = await this.ruleEngine.applyRules(filename, code, this.learnedPatterns);
      const complianceScore = this.calculateComplianceScore(violations);

      return {
        filename,
        complianceScore,
        violations: violations.map(v => ({
          rule: v.rule,
          category: v.category,
          severity: v.severity,
          message: v.message,
          line: v.line
        })),
        recommendations: this.generateRecommendations(violations),
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        filename,
        error: `Code analysis failed: ${error.message}`
      };
    }
  }

  async detectAICode(code, filename = 'temp.js') {
    if (!this.aiDetector) {
      return { error: 'AI detector not available' };
    }

    try {
      const result = await this.aiDetector.detectAICode(code, filename);
      
      return {
        filename,
        isAIGenerated: result.isLikelyAI,
        confidence: result.confidence,
        indicators: result.indicators.slice(0, 5), // Top 5 indicators
        recommendation: result.recommendation,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      return {
        filename,
        error: `AI detection failed: ${error.message}`
      };
    }
  }

  async getRecentViolations(limit = 10, severity = null) {
    const recentActivity = await this.getRecentActivityFromLogs();
    const violations = [];

    for (const analysis of recentActivity) {
      if (analysis.violations) {
        for (const violation of analysis.violations) {
          if (!severity || violation.severity === severity) {
            violations.push({
              ...violation,
              file: analysis.file,
              timestamp: analysis.timestamp
            });
          }
        }
      }
    }

    return {
      violations: violations.slice(0, limit),
      total: violations.length,
      filters: { severity, limit },
      timestamp: new Date().toISOString()
    };
  }

  async getFileAnalysis(filepath) {
    const recentActivity = await this.getRecentActivityFromLogs();
    const fileAnalysis = recentActivity.find(a => a.file === filepath);

    if (fileAnalysis) {
      return {
        file: filepath,
        lastAnalyzed: fileAnalysis.timestamp,
        ...fileAnalysis
      };
    }

    return {
      file: filepath,
      error: 'No recent analysis found for this file',
      suggestion: 'Make a change to the file to trigger analysis (ensure monitoring is running)'
    };
  }

  async suggestImprovements(code, filename = 'temp.js', focus = 'all') {
    const suggestions = [];
    
    try {
      const compliance = await this.checkCodeCompliance(code, filename);
      if (compliance.violations) {
        suggestions.push(...compliance.recommendations);
      }

      const aiDetection = await this.detectAICode(code, filename);
      if (aiDetection.isAIGenerated) {
        suggestions.push(aiDetection.recommendation);
        suggestions.push('Consider adding human review comments for AI-generated code');
      }

      if (this.monitor?.learnedPatterns) {
        const patterns = this.monitor.learnedPatterns.recommendations;
        
        if (focus === 'naming' || focus === 'all') {
          if (patterns.naming) {
            suggestions.push(`Project uses ${patterns.naming.variables} for variables and ${patterns.naming.functions} for functions`);
          }
        }

        if (focus === 'imports' || focus === 'all') {
          if (patterns.imports) {
            suggestions.push(`Project prefers ${patterns.imports.style} imports and ${patterns.imports.extensions} file extensions`);
          }
        }
      }

      return {
        filename,
        focus,
        suggestions: [...new Set(suggestions)], // Remove duplicates
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      return {
        filename,
        error: `Could not generate suggestions: ${error.message}`
      };
    }
  }


  calculateComplianceScore(violations) {
    const severityWeights = { critical: 20, high: 10, medium: 5, low: 2, info: 1 };
    const totalPenalty = violations.reduce((sum, v) => sum + (severityWeights[v.severity] || 0), 0);
    return Math.max(0, 100 - Math.min(totalPenalty, 100));
  }

  generateRecommendations(violations) {
    const recommendations = [];
    const violationsByCategory = violations.reduce((acc, v) => {
      acc[v.category] = (acc[v.category] || 0) + 1;
      return acc;
    }, {});

    Object.entries(violationsByCategory).forEach(([category, count]) => {
      if (count > 1) {
        recommendations.push(`Address ${count} ${category} violations for better code quality`);
      }
    });

    const criticalViolations = violations.filter(v => v.severity === 'critical');
    if (criticalViolations.length > 0) {
      recommendations.push('Critical violations must be fixed before deployment');
    }

    return recommendations;
  }

  async readRequestBody(req) {
    return new Promise((resolve, reject) => {
      let body = '';
      let size = 0;

      req.on('data', chunk => {
        size += chunk.length;
        if (size > this.options.maxRequestSize) {
          reject(new Error('Request too large'));
          return;
        }
        body += chunk;
      });

      req.on('end', () => resolve(body));
      req.on('error', reject);
    });
  }

  sendResponse(res, data) {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify(data, null, 2));
  }

  sendError(res, statusCode, message) {
    res.writeHead(statusCode, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ error: message, status: statusCode }));
  }
}